/*
 * Automatically generated from raft.rpc
 * by event_rpcgen.py/0.1.  DO NOT EDIT THIS FILE.
 */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <event2/event-config.h>
#include <event2/event.h>
#include <event2/buffer.h>
#include <event2/tag.h>

#ifdef _EVENT___func__
#define __func__ _EVENT___func__
#endif


#include "raft.gen.h"

void event_warn(const char *fmt, ...);
void event_warnx(const char *fmt, ...);


/*
 * Implementation of request_vote_request
 */

static struct request_vote_request_access_ __request_vote_request_base = {
  request_vote_request_term_assign,
  request_vote_request_term_get,
  request_vote_request_candidate_id_assign,
  request_vote_request_candidate_id_get,
  request_vote_request_last_log_index_assign,
  request_vote_request_last_log_index_get,
  request_vote_request_last_log_term_assign,
  request_vote_request_last_log_term_get,
};

struct request_vote_request *
request_vote_request_new(void)
{
  return request_vote_request_new_with_arg(NULL);
}

struct request_vote_request *
request_vote_request_new_with_arg(void *unused)
{
  struct request_vote_request *tmp;
  if ((tmp = malloc(sizeof(struct request_vote_request))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__request_vote_request_base;

  tmp->term_data = 0;
  tmp->term_set = 0;

  tmp->candidate_id_data = NULL;
  tmp->candidate_id_set = 0;

  tmp->last_log_index_data = 0;
  tmp->last_log_index_set = 0;

  tmp->last_log_term_data = 0;
  tmp->last_log_term_set = 0;

  return (tmp);
}





int
request_vote_request_term_assign(struct request_vote_request *msg, const ev_uint64_t value)
{
  msg->term_set = 1;
  msg->term_data = value;
  return (0);
}

int
request_vote_request_candidate_id_assign(struct request_vote_request *msg,
    const char * value)
{
  if (msg->candidate_id_data != NULL)
    free(msg->candidate_id_data);
  if ((msg->candidate_id_data = strdup(value)) == NULL)
    return (-1);
  msg->candidate_id_set = 1;
  return (0);
}

int
request_vote_request_last_log_index_assign(struct request_vote_request *msg, const ev_uint64_t value)
{
  msg->last_log_index_set = 1;
  msg->last_log_index_data = value;
  return (0);
}

int
request_vote_request_last_log_term_assign(struct request_vote_request *msg, const ev_uint64_t value)
{
  msg->last_log_term_set = 1;
  msg->last_log_term_data = value;
  return (0);
}

int
request_vote_request_term_get(struct request_vote_request *msg, ev_uint64_t *value)
{
  if (msg->term_set != 1)
    return (-1);
  *value = msg->term_data;
  return (0);
}

int
request_vote_request_candidate_id_get(struct request_vote_request *msg, char * *value)
{
  if (msg->candidate_id_set != 1)
    return (-1);
  *value = msg->candidate_id_data;
  return (0);
}

int
request_vote_request_last_log_index_get(struct request_vote_request *msg, ev_uint64_t *value)
{
  if (msg->last_log_index_set != 1)
    return (-1);
  *value = msg->last_log_index_data;
  return (0);
}

int
request_vote_request_last_log_term_get(struct request_vote_request *msg, ev_uint64_t *value)
{
  if (msg->last_log_term_set != 1)
    return (-1);
  *value = msg->last_log_term_data;
  return (0);
}

void
request_vote_request_clear(struct request_vote_request *tmp)
{
  tmp->term_set = 0;
  if (tmp->candidate_id_set == 1) {
    free(tmp->candidate_id_data);
    tmp->candidate_id_data = NULL;
    tmp->candidate_id_set = 0;
  }
  tmp->last_log_index_set = 0;
  tmp->last_log_term_set = 0;
}

void
request_vote_request_free(struct request_vote_request *tmp)
{
  if (tmp->candidate_id_data != NULL)
      free (tmp->candidate_id_data);
  free(tmp);
}

void
request_vote_request_marshal(struct evbuffer *evbuf, const struct request_vote_request *tmp){
  evtag_marshal_int64(evbuf, REQUEST_VOTE_REQUEST_TERM, tmp->term_data);
  evtag_marshal_string(evbuf, REQUEST_VOTE_REQUEST_CANDIDATE_ID, tmp->candidate_id_data);
  evtag_marshal_int64(evbuf, REQUEST_VOTE_REQUEST_LAST_LOG_INDEX, tmp->last_log_index_data);
  evtag_marshal_int64(evbuf, REQUEST_VOTE_REQUEST_LAST_LOG_TERM, tmp->last_log_term_data);
}

int
request_vote_request_unmarshal(struct request_vote_request *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case REQUEST_VOTE_REQUEST_TERM:

        if (tmp->term_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, REQUEST_VOTE_REQUEST_TERM, &tmp->term_data) == -1) {
          event_warnx("%s: failed to unmarshal term", __func__);
          return (-1);
        }
        tmp->term_set = 1;
        break;

      case REQUEST_VOTE_REQUEST_CANDIDATE_ID:

        if (tmp->candidate_id_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, REQUEST_VOTE_REQUEST_CANDIDATE_ID, &tmp->candidate_id_data) == -1) {
          event_warnx("%s: failed to unmarshal candidate_id", __func__);
          return (-1);
        }
        tmp->candidate_id_set = 1;
        break;

      case REQUEST_VOTE_REQUEST_LAST_LOG_INDEX:

        if (tmp->last_log_index_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, REQUEST_VOTE_REQUEST_LAST_LOG_INDEX, &tmp->last_log_index_data) == -1) {
          event_warnx("%s: failed to unmarshal last_log_index", __func__);
          return (-1);
        }
        tmp->last_log_index_set = 1;
        break;

      case REQUEST_VOTE_REQUEST_LAST_LOG_TERM:

        if (tmp->last_log_term_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, REQUEST_VOTE_REQUEST_LAST_LOG_TERM, &tmp->last_log_term_data) == -1) {
          event_warnx("%s: failed to unmarshal last_log_term", __func__);
          return (-1);
        }
        tmp->last_log_term_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (request_vote_request_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
request_vote_request_complete(struct request_vote_request *msg)
{
  if (!msg->term_set)
    return (-1);
  if (!msg->candidate_id_set)
    return (-1);
  if (!msg->last_log_index_set)
    return (-1);
  if (!msg->last_log_term_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_request_vote_request(struct evbuffer *evbuf, ev_uint32_t need_tag, struct request_vote_request *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (request_vote_request_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_request_vote_request(struct evbuffer *evbuf, ev_uint32_t tag, const struct request_vote_request *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  request_vote_request_marshal(_buf, msg);
  evtag_marshal_buffer(evbuf, tag, _buf);
   evbuffer_free(_buf);
}

/*
 * Implementation of request_vote_response
 */

static struct request_vote_response_access_ __request_vote_response_base = {
  request_vote_response_term_assign,
  request_vote_response_term_get,
  request_vote_response_vote_granted_assign,
  request_vote_response_vote_granted_get,
};

struct request_vote_response *
request_vote_response_new(void)
{
  return request_vote_response_new_with_arg(NULL);
}

struct request_vote_response *
request_vote_response_new_with_arg(void *unused)
{
  struct request_vote_response *tmp;
  if ((tmp = malloc(sizeof(struct request_vote_response))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__request_vote_response_base;

  tmp->term_data = 0;
  tmp->term_set = 0;

  tmp->vote_granted_data = 0;
  tmp->vote_granted_set = 0;

  return (tmp);
}



int
request_vote_response_term_assign(struct request_vote_response *msg, const ev_uint64_t value)
{
  msg->term_set = 1;
  msg->term_data = value;
  return (0);
}

int
request_vote_response_vote_granted_assign(struct request_vote_response *msg, const ev_uint32_t value)
{
  msg->vote_granted_set = 1;
  msg->vote_granted_data = value;
  return (0);
}

int
request_vote_response_term_get(struct request_vote_response *msg, ev_uint64_t *value)
{
  if (msg->term_set != 1)
    return (-1);
  *value = msg->term_data;
  return (0);
}

int
request_vote_response_vote_granted_get(struct request_vote_response *msg, ev_uint32_t *value)
{
  if (msg->vote_granted_set != 1)
    return (-1);
  *value = msg->vote_granted_data;
  return (0);
}

void
request_vote_response_clear(struct request_vote_response *tmp)
{
  tmp->term_set = 0;
  tmp->vote_granted_set = 0;
}

void
request_vote_response_free(struct request_vote_response *tmp)
{
  free(tmp);
}

void
request_vote_response_marshal(struct evbuffer *evbuf, const struct request_vote_response *tmp){
  evtag_marshal_int64(evbuf, REQUEST_VOTE_RESPONSE_TERM, tmp->term_data);
  evtag_marshal_int(evbuf, REQUEST_VOTE_RESPONSE_VOTE_GRANTED, tmp->vote_granted_data);
}

int
request_vote_response_unmarshal(struct request_vote_response *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case REQUEST_VOTE_RESPONSE_TERM:

        if (tmp->term_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, REQUEST_VOTE_RESPONSE_TERM, &tmp->term_data) == -1) {
          event_warnx("%s: failed to unmarshal term", __func__);
          return (-1);
        }
        tmp->term_set = 1;
        break;

      case REQUEST_VOTE_RESPONSE_VOTE_GRANTED:

        if (tmp->vote_granted_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, REQUEST_VOTE_RESPONSE_VOTE_GRANTED, &tmp->vote_granted_data) == -1) {
          event_warnx("%s: failed to unmarshal vote_granted", __func__);
          return (-1);
        }
        tmp->vote_granted_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (request_vote_response_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
request_vote_response_complete(struct request_vote_response *msg)
{
  if (!msg->term_set)
    return (-1);
  if (!msg->vote_granted_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_request_vote_response(struct evbuffer *evbuf, ev_uint32_t need_tag, struct request_vote_response *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (request_vote_response_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_request_vote_response(struct evbuffer *evbuf, ev_uint32_t tag, const struct request_vote_response *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  request_vote_response_marshal(_buf, msg);
  evtag_marshal_buffer(evbuf, tag, _buf);
   evbuffer_free(_buf);
}

/*
 * Implementation of entry
 */

static struct entry_access_ __entry_base = {
  entry_index_assign,
  entry_index_get,
  entry_command_assign,
  entry_command_get,
};

struct entry *
entry_new(void)
{
  return entry_new_with_arg(NULL);
}

struct entry *
entry_new_with_arg(void *unused)
{
  struct entry *tmp;
  if ((tmp = malloc(sizeof(struct entry))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__entry_base;

  tmp->index_data = 0;
  tmp->index_set = 0;

  tmp->command_data = NULL;
  tmp->command_set = 0;

  return (tmp);
}



int
entry_index_assign(struct entry *msg, const ev_uint64_t value)
{
  msg->index_set = 1;
  msg->index_data = value;
  return (0);
}

int
entry_command_assign(struct entry *msg,
    const char * value)
{
  if (msg->command_data != NULL)
    free(msg->command_data);
  if ((msg->command_data = strdup(value)) == NULL)
    return (-1);
  msg->command_set = 1;
  return (0);
}

int
entry_index_get(struct entry *msg, ev_uint64_t *value)
{
  if (msg->index_set != 1)
    return (-1);
  *value = msg->index_data;
  return (0);
}

int
entry_command_get(struct entry *msg, char * *value)
{
  if (msg->command_set != 1)
    return (-1);
  *value = msg->command_data;
  return (0);
}

void
entry_clear(struct entry *tmp)
{
  tmp->index_set = 0;
  if (tmp->command_set == 1) {
    free(tmp->command_data);
    tmp->command_data = NULL;
    tmp->command_set = 0;
  }
}

void
entry_free(struct entry *tmp)
{
  if (tmp->command_data != NULL)
      free (tmp->command_data);
  free(tmp);
}

void
entry_marshal(struct evbuffer *evbuf, const struct entry *tmp){
  evtag_marshal_int64(evbuf, ENTRY_INDEX, tmp->index_data);
  evtag_marshal_string(evbuf, ENTRY_COMMAND, tmp->command_data);
}

int
entry_unmarshal(struct entry *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case ENTRY_INDEX:

        if (tmp->index_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, ENTRY_INDEX, &tmp->index_data) == -1) {
          event_warnx("%s: failed to unmarshal index", __func__);
          return (-1);
        }
        tmp->index_set = 1;
        break;

      case ENTRY_COMMAND:

        if (tmp->command_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, ENTRY_COMMAND, &tmp->command_data) == -1) {
          event_warnx("%s: failed to unmarshal command", __func__);
          return (-1);
        }
        tmp->command_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (entry_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
entry_complete(struct entry *msg)
{
  if (!msg->index_set)
    return (-1);
  if (!msg->command_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_entry(struct evbuffer *evbuf, ev_uint32_t need_tag, struct entry *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (entry_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_entry(struct evbuffer *evbuf, ev_uint32_t tag, const struct entry *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  entry_marshal(_buf, msg);
  evtag_marshal_buffer(evbuf, tag, _buf);
   evbuffer_free(_buf);
}

/*
 * Implementation of append_entries_request
 */

static struct append_entries_request_access_ __append_entries_request_base = {
  append_entries_request_term_assign,
  append_entries_request_term_get,
  append_entries_request_leader_id_assign,
  append_entries_request_leader_id_get,
  append_entries_request_prev_log_index_assign,
  append_entries_request_prev_log_index_get,
  append_entries_request_prev_log_term_assign,
  append_entries_request_prev_log_term_get,
  append_entries_request_entries_assign,
  append_entries_request_entries_get,
  append_entries_request_entries_add,
  append_entries_request_leader_commit_assign,
  append_entries_request_leader_commit_get,
};

struct append_entries_request *
append_entries_request_new(void)
{
  return append_entries_request_new_with_arg(NULL);
}

struct append_entries_request *
append_entries_request_new_with_arg(void *unused)
{
  struct append_entries_request *tmp;
  if ((tmp = malloc(sizeof(struct append_entries_request))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__append_entries_request_base;

  tmp->term_data = 0;
  tmp->term_set = 0;

  tmp->leader_id_data = 0;
  tmp->leader_id_set = 0;

  tmp->prev_log_index_data = 0;
  tmp->prev_log_index_set = 0;

  tmp->prev_log_term_data = 0;
  tmp->prev_log_term_set = 0;

  tmp->entries_data = NULL;
  tmp->entries_length = 0;
  tmp->entries_num_allocated = 0;
  tmp->entries_set = 0;

  tmp->leader_commit_data = 0;
  tmp->leader_commit_set = 0;

  return (tmp);
}





static int
append_entries_request_entries_expand_to_hold_more(struct append_entries_request *msg)
{
  int tobe_allocated = msg->entries_num_allocated;
  struct entry** new_data = NULL;
  tobe_allocated = !tobe_allocated ? 1 : tobe_allocated << 1;
  new_data = (struct entry**) realloc(msg->entries_data,
      tobe_allocated * sizeof(struct entry*));
  if (new_data == NULL)
    return -1;
  msg->entries_data = new_data;
  msg->entries_num_allocated = tobe_allocated;
  return 0;}

struct entry* 
append_entries_request_entries_add(struct append_entries_request *msg)
{
  if (++msg->entries_length >= msg->entries_num_allocated) {
    if (append_entries_request_entries_expand_to_hold_more(msg)<0)
      goto error;
  }
  msg->entries_data[msg->entries_length - 1] = entry_new();
  if (msg->entries_data[msg->entries_length - 1] == NULL)
    goto error;
  msg->entries_set = 1;
  return (msg->entries_data[msg->entries_length - 1]);
error:
  --msg->entries_length;
  return (NULL);
}


int
append_entries_request_term_assign(struct append_entries_request *msg, const ev_uint64_t value)
{
  msg->term_set = 1;
  msg->term_data = value;
  return (0);
}

int
append_entries_request_leader_id_assign(struct append_entries_request *msg, const ev_uint64_t value)
{
  msg->leader_id_set = 1;
  msg->leader_id_data = value;
  return (0);
}

int
append_entries_request_prev_log_index_assign(struct append_entries_request *msg, const ev_uint64_t value)
{
  msg->prev_log_index_set = 1;
  msg->prev_log_index_data = value;
  return (0);
}

int
append_entries_request_prev_log_term_assign(struct append_entries_request *msg, const ev_uint64_t value)
{
  msg->prev_log_term_set = 1;
  msg->prev_log_term_data = value;
  return (0);
}

int
append_entries_request_entries_assign(struct append_entries_request *msg, int off,
    const struct entry* value)
{
  if (!msg->entries_set || off < 0 || off >= msg->entries_length)
    return (-1);

  {
    int had_error = 0;
    struct evbuffer *tmp = NULL;
    entry_clear(msg->entries_data[off]);
    if ((tmp = evbuffer_new()) == NULL) {
      event_warn("%s: evbuffer_new()", __func__);
      had_error = 1;
      goto done;
    }
    entry_marshal(tmp, value);
    if (entry_unmarshal(msg->entries_data[off], tmp) == -1) {
      event_warnx("%s: entry_unmarshal", __func__);
      had_error = 1;
      goto done;
    }
    done:if (tmp != NULL)
      evbuffer_free(tmp);
    if (had_error) {
      entry_clear(msg->entries_data[off]);
      return (-1);
    }
  }
  return (0);
}

int
append_entries_request_leader_commit_assign(struct append_entries_request *msg, const ev_uint64_t value)
{
  msg->leader_commit_set = 1;
  msg->leader_commit_data = value;
  return (0);
}

int
append_entries_request_term_get(struct append_entries_request *msg, ev_uint64_t *value)
{
  if (msg->term_set != 1)
    return (-1);
  *value = msg->term_data;
  return (0);
}

int
append_entries_request_leader_id_get(struct append_entries_request *msg, ev_uint64_t *value)
{
  if (msg->leader_id_set != 1)
    return (-1);
  *value = msg->leader_id_data;
  return (0);
}

int
append_entries_request_prev_log_index_get(struct append_entries_request *msg, ev_uint64_t *value)
{
  if (msg->prev_log_index_set != 1)
    return (-1);
  *value = msg->prev_log_index_data;
  return (0);
}

int
append_entries_request_prev_log_term_get(struct append_entries_request *msg, ev_uint64_t *value)
{
  if (msg->prev_log_term_set != 1)
    return (-1);
  *value = msg->prev_log_term_data;
  return (0);
}

int
append_entries_request_entries_get(struct append_entries_request *msg, int offset,
    struct entry* *value)
{
  if (!msg->entries_set || offset < 0 || offset >= msg->entries_length)
    return (-1);
  *value = msg->entries_data[offset];
  return (0);
}

int
append_entries_request_leader_commit_get(struct append_entries_request *msg, ev_uint64_t *value)
{
  if (msg->leader_commit_set != 1)
    return (-1);
  *value = msg->leader_commit_data;
  return (0);
}

void
append_entries_request_clear(struct append_entries_request *tmp)
{
  tmp->term_set = 0;
  tmp->leader_id_set = 0;
  tmp->prev_log_index_set = 0;
  tmp->prev_log_term_set = 0;
  if (tmp->entries_set == 1) {
    int i;
    for (i = 0; i < tmp->entries_length; ++i) {
      entry_free(tmp->entries_data[i]);
    }
    free(tmp->entries_data);
    tmp->entries_data = NULL;
    tmp->entries_set = 0;
    tmp->entries_length = 0;
    tmp->entries_num_allocated = 0;
  }
  tmp->leader_commit_set = 0;
}

void
append_entries_request_free(struct append_entries_request *tmp)
{
  if (tmp->entries_set == 1) {
    int i;
    for (i = 0; i < tmp->entries_length; ++i) {
      entry_free(tmp->entries_data[i]);
    }
    free(tmp->entries_data);
    tmp->entries_data = NULL;
    tmp->entries_set = 0;
    tmp->entries_length = 0;
    tmp->entries_num_allocated = 0;
  }
  free(tmp->entries_data);
  free(tmp);
}

void
append_entries_request_marshal(struct evbuffer *evbuf, const struct append_entries_request *tmp){
  evtag_marshal_int64(evbuf, APPEND_ENTRIES_REQUEST_TERM, tmp->term_data);
  evtag_marshal_int64(evbuf, APPEND_ENTRIES_REQUEST_LEADER_ID, tmp->leader_id_data);
  evtag_marshal_int64(evbuf, APPEND_ENTRIES_REQUEST_PREV_LOG_INDEX, tmp->prev_log_index_data);
  evtag_marshal_int64(evbuf, APPEND_ENTRIES_REQUEST_PREV_LOG_TERM, tmp->prev_log_term_data);
  if (tmp->entries_set) {
    {
      int i;
      for (i = 0; i < tmp->entries_length; ++i) {
    evtag_marshal_entry(evbuf, APPEND_ENTRIES_REQUEST_ENTRIES, tmp->entries_data[i]);
      }
    }
  }
  evtag_marshal_int64(evbuf, APPEND_ENTRIES_REQUEST_LEADER_COMMIT, tmp->leader_commit_data);
}

int
append_entries_request_unmarshal(struct append_entries_request *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case APPEND_ENTRIES_REQUEST_TERM:

        if (tmp->term_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, APPEND_ENTRIES_REQUEST_TERM, &tmp->term_data) == -1) {
          event_warnx("%s: failed to unmarshal term", __func__);
          return (-1);
        }
        tmp->term_set = 1;
        break;

      case APPEND_ENTRIES_REQUEST_LEADER_ID:

        if (tmp->leader_id_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, APPEND_ENTRIES_REQUEST_LEADER_ID, &tmp->leader_id_data) == -1) {
          event_warnx("%s: failed to unmarshal leader_id", __func__);
          return (-1);
        }
        tmp->leader_id_set = 1;
        break;

      case APPEND_ENTRIES_REQUEST_PREV_LOG_INDEX:

        if (tmp->prev_log_index_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, APPEND_ENTRIES_REQUEST_PREV_LOG_INDEX, &tmp->prev_log_index_data) == -1) {
          event_warnx("%s: failed to unmarshal prev_log_index", __func__);
          return (-1);
        }
        tmp->prev_log_index_set = 1;
        break;

      case APPEND_ENTRIES_REQUEST_PREV_LOG_TERM:

        if (tmp->prev_log_term_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, APPEND_ENTRIES_REQUEST_PREV_LOG_TERM, &tmp->prev_log_term_data) == -1) {
          event_warnx("%s: failed to unmarshal prev_log_term", __func__);
          return (-1);
        }
        tmp->prev_log_term_set = 1;
        break;

      case APPEND_ENTRIES_REQUEST_ENTRIES:

        if (tmp->entries_length >= tmp->entries_num_allocated &&
            append_entries_request_entries_expand_to_hold_more(tmp) < 0) {
          puts("HEY NOW");
          return (-1);
        }
        tmp->entries_data[tmp->entries_length] = entry_new();
        if (tmp->entries_data[tmp->entries_length] == NULL)
          return (-1);
        if (evtag_unmarshal_entry(evbuf, APPEND_ENTRIES_REQUEST_ENTRIES, tmp->entries_data[tmp->entries_length]) == -1) {
          event_warnx("%s: failed to unmarshal entries", __func__);
          return (-1);
        }
        ++tmp->entries_length;
        tmp->entries_set = 1;
        break;

      case APPEND_ENTRIES_REQUEST_LEADER_COMMIT:

        if (tmp->leader_commit_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, APPEND_ENTRIES_REQUEST_LEADER_COMMIT, &tmp->leader_commit_data) == -1) {
          event_warnx("%s: failed to unmarshal leader_commit", __func__);
          return (-1);
        }
        tmp->leader_commit_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (append_entries_request_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
append_entries_request_complete(struct append_entries_request *msg)
{
  if (!msg->term_set)
    return (-1);
  if (!msg->leader_id_set)
    return (-1);
  if (!msg->prev_log_index_set)
    return (-1);
  if (!msg->prev_log_term_set)
    return (-1);
  {
    int i;
    for (i = 0; i < msg->entries_length; ++i) {
      if (msg->entries_set && entry_complete(msg->entries_data[i]) == -1)
        return (-1);
    }
  }
  if (!msg->leader_commit_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_append_entries_request(struct evbuffer *evbuf, ev_uint32_t need_tag, struct append_entries_request *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (append_entries_request_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_append_entries_request(struct evbuffer *evbuf, ev_uint32_t tag, const struct append_entries_request *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  append_entries_request_marshal(_buf, msg);
  evtag_marshal_buffer(evbuf, tag, _buf);
   evbuffer_free(_buf);
}

/*
 * Implementation of append_entries_response
 */

static struct append_entries_response_access_ __append_entries_response_base = {
  append_entries_response_term_assign,
  append_entries_response_term_get,
  append_entries_response_success_assign,
  append_entries_response_success_get,
};

struct append_entries_response *
append_entries_response_new(void)
{
  return append_entries_response_new_with_arg(NULL);
}

struct append_entries_response *
append_entries_response_new_with_arg(void *unused)
{
  struct append_entries_response *tmp;
  if ((tmp = malloc(sizeof(struct append_entries_response))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &__append_entries_response_base;

  tmp->term_data = 0;
  tmp->term_set = 0;

  tmp->success_data = 0;
  tmp->success_set = 0;

  return (tmp);
}



int
append_entries_response_term_assign(struct append_entries_response *msg, const ev_uint64_t value)
{
  msg->term_set = 1;
  msg->term_data = value;
  return (0);
}

int
append_entries_response_success_assign(struct append_entries_response *msg, const ev_uint32_t value)
{
  msg->success_set = 1;
  msg->success_data = value;
  return (0);
}

int
append_entries_response_term_get(struct append_entries_response *msg, ev_uint64_t *value)
{
  if (msg->term_set != 1)
    return (-1);
  *value = msg->term_data;
  return (0);
}

int
append_entries_response_success_get(struct append_entries_response *msg, ev_uint32_t *value)
{
  if (msg->success_set != 1)
    return (-1);
  *value = msg->success_data;
  return (0);
}

void
append_entries_response_clear(struct append_entries_response *tmp)
{
  tmp->term_set = 0;
  tmp->success_set = 0;
}

void
append_entries_response_free(struct append_entries_response *tmp)
{
  free(tmp);
}

void
append_entries_response_marshal(struct evbuffer *evbuf, const struct append_entries_response *tmp){
  evtag_marshal_int64(evbuf, APPEND_ENTRIES_RESPONSE_TERM, tmp->term_data);
  evtag_marshal_int(evbuf, APPEND_ENTRIES_RESPONSE_SUCCESS, tmp->success_data);
}

int
append_entries_response_unmarshal(struct append_entries_response *tmp,  struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case APPEND_ENTRIES_RESPONSE_TERM:

        if (tmp->term_set)
          return (-1);
        if (evtag_unmarshal_int64(evbuf, APPEND_ENTRIES_RESPONSE_TERM, &tmp->term_data) == -1) {
          event_warnx("%s: failed to unmarshal term", __func__);
          return (-1);
        }
        tmp->term_set = 1;
        break;

      case APPEND_ENTRIES_RESPONSE_SUCCESS:

        if (tmp->success_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, APPEND_ENTRIES_RESPONSE_SUCCESS, &tmp->success_data) == -1) {
          event_warnx("%s: failed to unmarshal success", __func__);
          return (-1);
        }
        tmp->success_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (append_entries_response_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
append_entries_response_complete(struct append_entries_response *msg)
{
  if (!msg->term_set)
    return (-1);
  if (!msg->success_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_append_entries_response(struct evbuffer *evbuf, ev_uint32_t need_tag, struct append_entries_response *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (append_entries_response_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_append_entries_response(struct evbuffer *evbuf, ev_uint32_t tag, const struct append_entries_response *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  append_entries_response_marshal(_buf, msg);
  evtag_marshal_buffer(evbuf, tag, _buf);
   evbuffer_free(_buf);
}

